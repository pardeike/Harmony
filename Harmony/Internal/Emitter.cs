using MonoMod.Utils;
using MonoMod.Utils.Cil;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace HarmonyLib
{
	internal class LeaveTry
	{
		public override string ToString() => "(autogenerated)";
	}

	internal class Emitter
	{
		readonly ILGenerator iLGenerator;
		readonly CecilILGenerator il;
		readonly Dictionary<int, CodeInstruction> instructions = [];

		internal Emitter(ILGenerator il)
		{
			iLGenerator = il;
			this.il = il.GetProxiedShim<CecilILGenerator>();
		}

		internal Dictionary<int, CodeInstruction> GetInstructions() => instructions;

		internal void AddInstruction(OpCode opcode, object operand = null) => instructions.Add(CurrentPos(), new CodeInstruction(opcode, operand));

		internal int CurrentPos() => il.ILOffset;

		internal static string CodePos(int offset) => string.Format("IL_{0:X4}: ", offset);

		internal string CodePos() => CodePos(CurrentPos());

		internal IEnumerable<Mono.Cecil.Cil.VariableDefinition> Variables() => il.IL.Body.Variables;

		internal static string FormatOperand(object argument)
		{
			if (argument is null)
				return "NULL";
			var type = argument.GetType();

			if (argument is MethodBase method)
				return method.FullDescription();

			if (argument is FieldInfo field)
				return $"{field.FieldType.FullDescription()} {field.DeclaringType.FullDescription()}::{field.Name}";

			if (type == typeof(Label))
				return $"Label{((Label)argument).GetHashCode()}";

			if (type == typeof(Label[]))
				return $"Labels{string.Join(",", [.. ((Label[])argument).Select(l => l.GetHashCode().ToString())])}";

			if (type == typeof(LocalBuilder))
				return $"{((LocalBuilder)argument).LocalIndex} ({((LocalBuilder)argument).LocalType})";

			if (type == typeof(string))
				return argument.ToString().ToLiteral();

			return argument.ToString().Trim();
		}

		internal LocalBuilder DeclareLocalVariable(Type type, bool isReturnValue = false)
		{
			if (type.IsByRef)
			{
				if (isReturnValue)
				{
					var v = il.DeclareLocal(type);
					Emit(OpCodes.Ldc_I4_1);
					Emit(OpCodes.Newarr, type.GetElementType());
					Emit(OpCodes.Ldc_I4_0);
					Emit(OpCodes.Ldelema, type.GetElementType());
					Emit(OpCodes.Stloc, v);
					return v;
				}
				else
					type = type.GetElementType();
			}
			if (type.IsEnum)
				type = Enum.GetUnderlyingType(type);

			if (AccessTools.IsClass(type))
			{
				var v = il.DeclareLocal(type);
				Emit(OpCodes.Ldnull);
				Emit(OpCodes.Stloc, v);
				return v;
			}
			if (AccessTools.IsStruct(type))
			{
				var v = il.DeclareLocal(type);
				Emit(OpCodes.Ldloca, v);
				Emit(OpCodes.Initobj, type);
				return v;
			}
			if (AccessTools.IsValue(type))
			{
				var v = il.DeclareLocal(type);
				if (type == typeof(float))
					Emit(OpCodes.Ldc_R4, (float)0);
				else if (type == typeof(double))
					Emit(OpCodes.Ldc_R8, (double)0);
				else if (type == typeof(long) || type == typeof(ulong))
					Emit(OpCodes.Ldc_I8, (long)0);
				else
					Emit(OpCodes.Ldc_I4, 0);
				Emit(OpCodes.Stloc, v);
				return v;
			}
			return null;
		}

		internal void InitializeOutParameter(int argIndex, Type type)
		{
			if (type.IsByRef)
				type = type.GetElementType();
			Emit(OpCodes.Ldarg, argIndex);

			if (AccessTools.IsStruct(type))
			{
				Emit(OpCodes.Initobj, type);
				return;
			}

			if (AccessTools.IsValue(type))
			{
				if (type == typeof(float))
				{
					Emit(OpCodes.Ldc_R4, (float)0);
					Emit(OpCodes.Stind_R4);
					return;
				}
				else if (type == typeof(double))
				{
					Emit(OpCodes.Ldc_R8, (double)0);
					Emit(OpCodes.Stind_R8);
					return;
				}
				else if (type == typeof(long))
				{
					Emit(OpCodes.Ldc_I8, (long)0);
					Emit(OpCodes.Stind_I8);
					return;
				}
				else
				{
					Emit(OpCodes.Ldc_I4, 0);
					Emit(OpCodes.Stind_I4);
					return;
				}
			}

			// class or default
			Emit(OpCodes.Ldnull);
			Emit(OpCodes.Stind_Ref);
		}

		internal void PrepareArgumentArray(MethodBase original)
		{
			var parameters = original.GetParameters();
			var i = 0;
			foreach (var pInfo in parameters)
			{
				var argIndex = i++ + (original.IsStatic ? 0 : 1);
				if (pInfo.IsOut || pInfo.IsRetval)
					InitializeOutParameter(argIndex, pInfo.ParameterType);
			}
			Emit(OpCodes.Ldc_I4, parameters.Length);
			Emit(OpCodes.Newarr, typeof(object));
			i = 0;
			var arrayIdx = 0;
			foreach (var pInfo in parameters)
			{
				var argIndex = i++ + (original.IsStatic ? 0 : 1);
				var pType = pInfo.ParameterType;
				var paramByRef = pType.IsByRef;
				if (paramByRef)
					pType = pType.GetElementType();
				Emit(OpCodes.Dup);
				Emit(OpCodes.Ldc_I4, arrayIdx++);
				Emit(OpCodes.Ldarg, argIndex);
				if (paramByRef)
				{
					if (AccessTools.IsStruct(pType))
						Emit(OpCodes.Ldobj, pType);
					else
						Emit(MethodPatcherTools.LoadIndOpCodeFor(pType));
				}
				if (pType.IsValueType)
					Emit(OpCodes.Box, pType);
				Emit(OpCodes.Stelem_Ref);
			}
		}

		internal void RestoreArgumentArray(MethodBase original, LocalBuilderState localState)
		{
			var parameters = original.GetParameters();
			var i = 0;
			var arrayIdx = 0;
			foreach (var pInfo in parameters)
			{
				var argIndex = i++ + (original.IsStatic ? 0 : 1);
				var pType = pInfo.ParameterType;
				if (pType.IsByRef)
				{
					pType = pType.GetElementType();

					Emit(OpCodes.Ldarg, argIndex);
					Emit(OpCodes.Ldloc, localState[MethodPatcherTools.ARGS_ARRAY_VAR]);
					Emit(OpCodes.Ldc_I4, arrayIdx);
					Emit(OpCodes.Ldelem_Ref);

					if (pType.IsValueType)
					{
						Emit(OpCodes.Unbox_Any, pType);
						if (AccessTools.IsStruct(pType))
							Emit(OpCodes.Stobj, pType);
						else
							Emit(MethodPatcherTools.StoreIndOpCodeFor(pType));
					}
					else
					{
						Emit(OpCodes.Castclass, pType);
						Emit(OpCodes.Stind_Ref);
					}
				}
				else
				{
					Emit(OpCodes.Ldloc, localState[MethodPatcherTools.ARGS_ARRAY_VAR]);
					Emit(OpCodes.Ldc_I4, arrayIdx);
					Emit(OpCodes.Ldelem_Ref);
					if (pType.IsValueType)
						Emit(OpCodes.Unbox_Any, pType);
					else
						Emit(OpCodes.Castclass, pType);
					Emit(OpCodes.Starg, argIndex);
				}
				arrayIdx++;
			}
		}

		internal void MarkLabel(Label label) => il.MarkLabel(label);

		internal void MarkBlockBefore(ExceptionBlock block, out Label? label)
		{
			label = null;
			switch (block.blockType)
			{
				case ExceptionBlockType.BeginExceptionBlock:
					label = il.BeginExceptionBlock();
					break;

				case ExceptionBlockType.BeginCatchBlock:
					il.BeginCatchBlock(block.catchType);
					break;

				case ExceptionBlockType.BeginExceptFilterBlock:
					il.BeginExceptFilterBlock();
					break;

				case ExceptionBlockType.BeginFaultBlock:
					il.BeginFaultBlock();
					break;

				case ExceptionBlockType.BeginFinallyBlock:
					il.BeginFinallyBlock();
					break;
			}
		}

		internal void MarkBlockAfter(ExceptionBlock block)
		{
			switch (block.blockType)
			{
				case ExceptionBlockType.EndExceptionBlock:
					il.EndExceptionBlock();
					break;
			}
		}

		internal void Emit(OpCode opcode)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode));
			il.Emit(opcode);
		}

		internal void Emit(OpCode opcode, LocalBuilder local)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, local));
			il.Emit(opcode, local);
		}

		internal void Emit(OpCode opcode, FieldInfo field)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, field));
			il.Emit(opcode, field);
		}

		internal void Emit(OpCode opcode, Label[] labels)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, labels));
			il.Emit(opcode, labels);
		}

		internal void Emit(OpCode opcode, Label label)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, label));
			il.Emit(opcode, label);
		}

		internal void Emit(OpCode opcode, string str)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, str));
			il.Emit(opcode, str);
		}

		internal void Emit(OpCode opcode, float arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, byte arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, sbyte arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, double arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, int arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, MethodInfo meth)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, meth));
			il.Emit(opcode, meth);
		}

		internal void Emit(OpCode opcode, short arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, SignatureHelper signature)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, signature));
			il.Emit(opcode, signature);
		}

		internal void Emit(OpCode opcode, ConstructorInfo con)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, con));
			il.Emit(opcode, con);
		}

		internal void Emit(OpCode opcode, Type cls)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, cls));
			il.Emit(opcode, cls);
		}

		internal void Emit(OpCode opcode, long arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, ICallSiteGenerator operand)
			=> il.Emit(opcode, operand);

		internal void EmitCall(OpCode opcode, MethodInfo methodInfo)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, methodInfo));
			il.EmitCall(opcode, methodInfo, null);
		}

		internal void DynEmit(OpCode opcode, object operand)
			=> iLGenerator.DynEmit(opcode, operand);
	}
}
