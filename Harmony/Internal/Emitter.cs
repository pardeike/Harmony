using MonoMod.Utils.Cil;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace HarmonyLib
{
	internal class LeaveTry
	{
		public override string ToString()
		{
			return "(autogenerated)";
		}
	}

	internal class Emitter
	{
		readonly CecilILGenerator il;
		readonly Dictionary<int, CodeInstruction> instructions = new();
		readonly bool debug;

		internal Emitter(ILGenerator il, bool debug)
		{
			this.il = il.GetProxiedShim<CecilILGenerator>();
			this.debug = debug;
		}

		internal Dictionary<int, CodeInstruction> GetInstructions()
		{
			return instructions;
		}

		internal void AddInstruction(OpCode opcode, object operand)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, operand));
		}

		internal int CurrentPos()
		{
			return il.ILOffset;
		}

		internal static string CodePos(int offset)
		{
			return string.Format("IL_{0:X4}: ", offset);
		}

		internal string CodePos()
		{
			return CodePos(CurrentPos());
		}

		internal void LogComment(string comment)
		{
			if (debug)
			{
				var str = string.Format("{0}// {1}", CodePos(), comment);
				FileLog.LogBuffered(str);
			}
		}

		internal void LogIL(OpCode opcode)
		{
			if (debug)
				FileLog.LogBuffered(string.Format("{0}{1}", CodePos(), opcode));
		}

		internal void LogIL(OpCode opcode, object arg, string extra = null)
		{
			if (debug)
			{
				var argStr = FormatArgument(arg, extra);
				var space = argStr.Length > 0 ? " " : "";
				var opcodeName = opcode.ToString();
				if (opcode.FlowControl == FlowControl.Branch || opcode.FlowControl == FlowControl.Cond_Branch) opcodeName += " =>";
				opcodeName = opcodeName.PadRight(10);
				FileLog.LogBuffered(string.Format("{0}{1}{2}{3}", CodePos(), opcodeName, space, argStr));
			}
		}

		internal void LogAllLocalVariables()
		{
			if (debug is false)
				return;

			il.IL.Body.Variables.Do(v =>
			{
				var str = string.Format("{0}Local var {1}: {2}{3}", CodePos(0), v.Index, v.VariableType.FullName, v.IsPinned ? "(pinned)" : "");
				FileLog.LogBuffered(str);
			});
		}

		internal static string FormatArgument(object argument, string extra = null)
		{
			if (argument is null) return "NULL";
			var type = argument.GetType();

			if (argument is MethodBase method)
				return method.FullDescription() + (extra is object ? " " + extra : "");

			if (argument is FieldInfo field)
				return $"{field.FieldType.FullDescription()} {field.DeclaringType.FullDescription()}::{field.Name}";

			if (type == typeof(Label))
				return $"Label{((Label)argument).GetHashCode()}";

			if (type == typeof(Label[]))
				return $"Labels{string.Join(",", ((Label[])argument).Select(l => l.GetHashCode().ToString()).ToArray())}";

			if (type == typeof(LocalBuilder))
				return $"{((LocalBuilder)argument).LocalIndex} ({((LocalBuilder)argument).LocalType})";

			if (type == typeof(string))
				return argument.ToString().ToLiteral();

			return argument.ToString().Trim();
		}

		internal void MarkLabel(Label label)
		{
			if (debug) FileLog.LogBuffered(CodePos() + FormatArgument(label));
			il.MarkLabel(label);
		}

		internal void MarkBlockBefore(ExceptionBlock block, out Label? label)
		{
			label = null;
			switch (block.blockType)
			{
				case ExceptionBlockType.BeginExceptionBlock:
					if (debug)
					{
						FileLog.LogBuffered(".try");
						FileLog.LogBuffered("{");
						FileLog.ChangeIndent(1);
					}
					label = il.BeginExceptionBlock();
					return;

				case ExceptionBlockType.BeginCatchBlock:
					if (debug)
					{
						// fake log a LEAVE code since BeginCatchBlock() does add it
						LogIL(OpCodes.Leave, new LeaveTry());

						FileLog.ChangeIndent(-1);
						FileLog.LogBuffered("} // end try");

						FileLog.LogBuffered($".catch {block.catchType}");
						FileLog.LogBuffered("{");
						FileLog.ChangeIndent(1);
					}
					il.BeginCatchBlock(block.catchType);
					return;

				case ExceptionBlockType.BeginExceptFilterBlock:
					if (debug)
					{
						// fake log a LEAVE code since BeginCatchBlock() does add it
						LogIL(OpCodes.Leave, new LeaveTry());

						FileLog.ChangeIndent(-1);
						FileLog.LogBuffered("} // end try");

						FileLog.LogBuffered(".filter");
						FileLog.LogBuffered("{");
						FileLog.ChangeIndent(1);
					}
					il.BeginExceptFilterBlock();
					return;

				case ExceptionBlockType.BeginFaultBlock:
					if (debug)
					{
						// fake log a LEAVE code since BeginCatchBlock() does add it
						LogIL(OpCodes.Leave, new LeaveTry());

						FileLog.ChangeIndent(-1);
						FileLog.LogBuffered("} // end try");

						FileLog.LogBuffered(".fault");
						FileLog.LogBuffered("{");
						FileLog.ChangeIndent(1);
					}
					il.BeginFaultBlock();
					return;

				case ExceptionBlockType.BeginFinallyBlock:
					if (debug)
					{
						// fake log a LEAVE code since BeginCatchBlock() does add it
						LogIL(OpCodes.Leave, new LeaveTry());

						FileLog.ChangeIndent(-1);
						FileLog.LogBuffered("} // end try");

						FileLog.LogBuffered(".finally");
						FileLog.LogBuffered("{");
						FileLog.ChangeIndent(1);
					}
					il.BeginFinallyBlock();
					return;
			}
		}

		internal void MarkBlockAfter(ExceptionBlock block)
		{
			if (block.blockType == ExceptionBlockType.EndExceptionBlock)
			{
				if (debug)
				{
					// fake log a LEAVE code since BeginCatchBlock() does add it
					LogIL(OpCodes.Leave, new LeaveTry());

					FileLog.ChangeIndent(-1);
					FileLog.LogBuffered("} // end handler");
				}
				il.EndExceptionBlock();
			}
		}

		internal void Emit(OpCode opcode)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode));
			LogIL(opcode);
			il.Emit(opcode);
		}

		internal void Emit(OpCode opcode, LocalBuilder local)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, local));
			LogIL(opcode, local);
			il.Emit(opcode, local);
		}

		internal void Emit(OpCode opcode, FieldInfo field)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, field));
			LogIL(opcode, field);
			il.Emit(opcode, field);
		}

		internal void Emit(OpCode opcode, Label[] labels)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, labels));
			LogIL(opcode, labels);
			il.Emit(opcode, labels);
		}

		internal void Emit(OpCode opcode, Label label)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, label));
			LogIL(opcode, label);
			il.Emit(opcode, label);
		}

		internal void Emit(OpCode opcode, string str)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, str));
			LogIL(opcode, str);
			il.Emit(opcode, str);
		}

		internal void Emit(OpCode opcode, float arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, byte arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, sbyte arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, double arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, int arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, MethodInfo meth)
		{
			if (opcode.Equals(OpCodes.Call) || opcode.Equals(OpCodes.Callvirt) || opcode.Equals(OpCodes.Newobj))
			{
				EmitCall(opcode, meth, null);
				return;
			}

			instructions.Add(CurrentPos(), new CodeInstruction(opcode, meth));

			LogIL(opcode, meth);
			il.Emit(opcode, meth);
		}

		internal void Emit(OpCode opcode, short arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void Emit(OpCode opcode, SignatureHelper signature)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, signature));
			LogIL(opcode, signature);
			il.Emit(opcode, signature);
		}

		internal void Emit(OpCode opcode, ConstructorInfo con)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, con));
			LogIL(opcode, con);
			il.Emit(opcode, con);
		}

		internal void Emit(OpCode opcode, Type cls)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, cls));
			LogIL(opcode, cls);
			il.Emit(opcode, cls);
		}

		internal void Emit(OpCode opcode, long arg)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
			LogIL(opcode, arg);
			il.Emit(opcode, arg);
		}

		internal void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, methodInfo));
			var extra = optionalParameterTypes is object && optionalParameterTypes.Length > 0 ? optionalParameterTypes.Description() : null;
			LogIL(opcode, methodInfo, extra);
			il.EmitCall(opcode, methodInfo, optionalParameterTypes);
		}

#if NETSTANDARD2_0 || NETCOREAPP2_0
#else
		internal void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, unmanagedCallConv));
			var extra = returnType.FullName + " " + parameterTypes.Description();
			LogIL(opcode, unmanagedCallConv, extra);
			il.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
		}
#endif

		internal void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
		{
			instructions.Add(CurrentPos(), new CodeInstruction(opcode, callingConvention));
			var extra = returnType.FullName + " " + parameterTypes.Description() + " " + optionalParameterTypes.Description();
			LogIL(opcode, callingConvention, extra);
			il.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
		}
	}
}
